import{A as L,k as N,m as P,I as R,p as T,n as F,o as O,q,r as b,t as j,u as D,v as $,x as H,L as U,y as k,f as W,z as V,C as G,e as I,D as v,F as K,B as C,G as J,J as Q,K as z,M as X,N as S,O as Y,P as Z,Q as M,R as ee,S as E,V as te,i as ne,s as se,W as ae,X as re,Y as oe,Z as ie,_ as ce}from"./index-txgEeEVz.js";function me(t,e){if(t.length!==e.length)throw new L({expectedLength:t.length,givenLength:e.length});const r=[];for(let o=0;o<t.length;o++){const u=t[o],c=e[o];r.push(_(u,c))}return N(r)}function _(t,e,r=!1){if(t==="address"){const a=e;if(!P(a))throw new R({address:a});return T(a.toLowerCase(),{size:r?32:null})}if(t==="string")return F(e);if(t==="bytes")return e;if(t==="bool")return T(O(e),{size:r?32:1});const o=t.match(q);if(o){const[a,n,d="256"]=o,l=Number.parseInt(d,10)/8;return b(e,{size:r?32:l,signed:n==="int"})}const u=t.match(j);if(u){const[a,n]=u;if(Number.parseInt(n,10)!==(e.length-2)/2)throw new D({expectedSize:Number.parseInt(n,10),givenSize:(e.length-2)/2});return T(e,{dir:"right",size:r?32:null})}const c=t.match($);if(c&&Array.isArray(e)){const[a,n]=c,d=[];for(let l=0;l<e.length;l++)d.push(_(n,e[l],!0));return d.length===0?"0x":N(d)}throw new H(t)}function ue(t){const{source:e}=t,r=new Map,o=new U(8192),u=new Map,c=({address:a,chainId:n})=>`${a}.${n}`;return{async consume({address:a,chainId:n,client:d}){const l=c({address:a,chainId:n}),s=this.get({address:a,chainId:n,client:d});this.increment({address:a,chainId:n});const y=await s;return await e.set({address:a,chainId:n},y),o.set(l,y),y},async increment({address:a,chainId:n}){const d=c({address:a,chainId:n}),l=r.get(d)??0;r.set(d,l+1)},async get({address:a,chainId:n,client:d}){const l=c({address:a,chainId:n});let s=u.get(l);return s||(s=(async()=>{try{const p=await e.get({address:a,chainId:n,client:d}),i=o.get(l)??0;return i>0&&p<=i?i+1:(o.delete(l),p)}finally{this.reset({address:a,chainId:n})}})(),u.set(l,s)),(r.get(l)??0)+await s},reset({address:a,chainId:n}){const d=c({address:a,chainId:n});r.delete(d),u.delete(d)}}}function de(){return{async get(t){const{address:e,client:r}=t;return k(r,{address:e,blockTag:"pending"})},set(){}}}const we=ue({source:de()}),le="0x6492649264926492649264926492649264926492649264926492649264926492",ye="0x0000000000000000000000000000000000000000000000000000000000000000";function be(t){const{address:e,data:r,signature:o,to:u="hex"}=t,c=N([W([{type:"address"},{type:"bytes"},{type:"bytes"}],[e,r,o]),le]);return u==="hex"?c:V(c)}const A="0x5792579257925792579257925792579257925792579257925792579257925792",B=b(0,{size:32});async function xe(t,e){const{account:r=t.account,capabilities:o,chain:u=t.chain,experimental_fallback:c,experimental_fallbackDelay:a=32,forceAtomic:n=!1,id:d,version:l="2.0.0"}=e,s=r?v(r):null,y=e.calls.map(p=>{const i=p,g=i.abi?G({abi:i.abi,functionName:i.functionName,args:i.args}):i.data;return{data:i.dataSuffix&&g?I([g,i.dataSuffix]):g,to:i.to,value:i.value?b(i.value):void 0}});try{const p=await t.request({method:"wallet_sendCalls",params:[{atomicRequired:n,calls:y,capabilities:o,chainId:b(u.id),from:s==null?void 0:s.address,id:d,version:l}]},{retryCount:0});return typeof p=="string"?{id:p}:p}catch(p){const i=p;if(c&&(i.name==="MethodNotFoundRpcError"||i.name==="MethodNotSupportedRpcError"||i.name==="UnknownRpcError"||i.details.toLowerCase().includes("does not exist / is not available")||i.details.toLowerCase().includes("missing or invalid. request()")||i.details.toLowerCase().includes("did not match any variant of untagged enum")||i.details.toLowerCase().includes("account upgraded to unsupported contract")||i.details.toLowerCase().includes("eip-7702 not supported")||i.details.toLowerCase().includes("unsupported wc_ method")||i.details.toLowerCase().includes("feature toggled misconfigured"))){if(o&&Object.values(o).some(w=>!w.optional)){const w="non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";throw new K(new C(w,{details:w}))}if(n&&y.length>1){const h="`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";throw new J(new C(h,{details:h}))}const g=[];for(const h of y){const w=Q(t,{account:s,chain:u,data:h.data,to:h.to,value:h.value?z(h.value):void 0});g.push(w),a>0&&await new Promise(x=>setTimeout(x,a))}const m=await Promise.allSettled(g);if(m.every(h=>h.status==="rejected"))throw m[0].reason;const f=m.map(h=>h.status==="fulfilled"?h.value:B);return{id:I([...f,b(u.id,{size:32}),A])}}throw X(p,{...e,account:s,chain:e.chain})}}async function fe(t,e){async function r(s){if(s.endsWith(A.slice(2))){const p=Z(M(s,-64,-32)),i=M(s,0,-64).slice(2).match(/.{1,64}/g),g=await Promise.all(i.map(f=>B.slice(2)!==f?t.request({method:"eth_getTransactionReceipt",params:[`0x${f}`]},{dedupe:!0}):void 0)),m=g.some(f=>f===null)?100:g.every(f=>(f==null?void 0:f.status)==="0x1")?200:g.every(f=>(f==null?void 0:f.status)==="0x0")?500:600;return{atomic:!1,chainId:S(p),receipts:g.filter(Boolean),status:m,version:"2.0.0"}}return t.request({method:"wallet_getCallsStatus",params:[s]})}const{atomic:o=!1,chainId:u,receipts:c,version:a="2.0.0",...n}=await r(e.id),[d,l]=(()=>{const s=n.status;return s>=100&&s<200?["pending",s]:s>=200&&s<300?["success",s]:s>=300&&s<700?["failure",s]:s==="CONFIRMED"?["success",200]:s==="PENDING"?["pending",100]:[void 0,s]})();return{...n,atomic:o,chainId:u?S(u):void 0,receipts:(c==null?void 0:c.map(s=>({...s,blockNumber:z(s.blockNumber),gasUsed:z(s.gasUsed),status:Y[s.status]})))??[],statusCode:l,status:d,version:a}}async function Ce(t,e){var d;const{account:r=t.account,chainId:o,nonce:u}=e;if(!r)throw new ee({docsPath:"/docs/eip7702/prepareAuthorization"});const c=v(r),a=(()=>{if(e.executor)return e.executor==="self"?e.executor:v(e.executor)})(),n={address:e.contractAddress??e.address,chainId:o,nonce:u};return typeof n.chainId>"u"&&(n.chainId=((d=t.chain)==null?void 0:d.id)??await E(t,te,"getChainId")({})),typeof n.nonce>"u"&&(n.nonce=await E(t,k,"getTransactionCount")({address:c.address,blockTag:"pending"}),(a==="self"||a!=null&&a.address&&ne(a.address,c.address))&&(n.nonce+=1)),n}class pe extends C{constructor(e){super(`Call bundle failed with status: ${e.statusCode}`,{name:"BundleFailedError"}),Object.defineProperty(this,"result",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.result=e}}async function Te(t,e){const{id:r,pollingInterval:o=t.pollingInterval,status:u=({statusCode:m})=>m===200||m>=300,retryCount:c=4,retryDelay:a=({count:m})=>~~(1<<m)*200,timeout:n=6e4,throwOnFailure:d=!1}=e,l=se(["waitForCallsStatus",t.uid,r]),{promise:s,resolve:y,reject:p}=ae();let i;const g=re(l,{resolve:y,reject:p},m=>{const f=oe(async()=>{const h=w=>{clearTimeout(i),f(),w(),g()};try{const w=await ie(async()=>{const x=await E(t,fe,"getCallsStatus")({id:r});if(d&&x.status==="failure")throw new pe(x);return x},{retryCount:c,delay:a});if(!u(w))return;h(()=>m.resolve(w))}catch(w){h(()=>m.reject(w))}},{interval:o,emitOnBegin:!0});return f});return i=n?setTimeout(()=>{g(),clearTimeout(i),p(new he({id:r}))},n):void 0,await s}class he extends C{constructor({id:e}){super(`Timed out while waiting for call bundle with id "${e}" to be confirmed.`,{name:"WaitForCallsStatusTimeoutError"})}}function ve(t){const{r:e,s:r}=ce.Signature.fromCompact(t.slice(2,130)),o=+`0x${t.slice(130)}`,[u,c]=(()=>{if(o===0||o===1)return[void 0,o];if(o===27)return[BigInt(o),0];if(o===28)return[BigInt(o),1];throw new Error("Invalid yParityOrV value")})();return typeof u<"u"?{r:b(e,{size:32}),s:b(r,{size:32}),v:u,yParity:c}:{r:b(e,{size:32}),s:b(r,{size:32}),yParity:c}}export{pe as B,he as W,me as a,ve as b,ue as c,be as d,le as e,fe as g,we as n,Ce as p,xe as s,Te as w,ye as z};
